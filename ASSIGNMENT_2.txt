1. Create a Jenkins file to construct and upload Docker images to your Docker-hub registries. Ensure that when the branch is 'dev', 
the image is constructed and uploaded to the DEV Docker-hub registry. Similarly, when the branch is 'QA', it should be sent to the QA Docker-hub registry.
SOLUTION:-

DEV BRANCH
Started by user saniya ahaikh
 > git rev-parse --resolve-git-dir /var/jenkins_home/caches/git-0ea74179bf36a1e3b933260d312cc235/.git # timeout=10
Setting origin to https://github.com/Saniya2822/Jenkins.git
 > git config remote.origin.url https://github.com/Saniya2822/Jenkins.git # timeout=10
Fetching origin...
Fetching upstream changes from origin
 > git --version # timeout=10
 > git --version # 'git version 2.39.2'
 > git config --get remote.origin.url # timeout=10
using GIT_SSH to set credentials GIT_CREDS
Verifying host key using known hosts file
You're using 'Known hosts file' strategy to verify ssh host keys, but your known_hosts file does not exist, please go to 'Manage Jenkins' -> 'Security' -> 'Git Host Key Verification Configuration' and configure host key verification.
 > git fetch --tags --force --progress -- origin +refs/heads/*:refs/remotes/origin/* # timeout=10
Seen branch in repository origin/DEV
Seen branch in repository origin/QA
Seen branch in repository origin/main
Seen 3 remote branches
Obtained Jenkinsfile from b652a52252ee27894806ccc46527f89f28087d66
[Pipeline] Start of Pipeline
[Pipeline] node
Running on Jenkins in /var/jenkins_home/workspace/Question1_DEV
[Pipeline] {
[Pipeline] stage
[Pipeline] { (Declarative: Checkout SCM)
[Pipeline] checkout
Selected Git installation does not exist. Using Default
The recommended git tool is: NONE
using credential GIT_CREDS
Cloning the remote Git repository
Cloning with configured refspecs honoured and without tags
Cloning repository https://github.com/Saniya2822/Jenkins.git
 > git init /var/jenkins_home/workspace/Question1_DEV # timeout=10
Fetching upstream changes from https://github.com/Saniya2822/Jenkins.git
 > git --version # timeout=10
 > git --version # 'git version 2.39.2'
using GIT_SSH to set credentials GIT_CREDS
Verifying host key using known hosts file
You're using 'Known hosts file' strategy to verify ssh host keys, but your known_hosts file does not exist, please go to 'Manage Jenkins' -> 'Security' -> 'Git Host Key Verification Configuration' and configure host key verification.
 > git fetch --no-tags --force --progress -- https://github.com/Saniya2822/Jenkins.git +refs/heads/*:refs/remotes/origin/* # timeout=10
 > git config remote.origin.url https://github.com/Saniya2822/Jenkins.git # timeout=10
 > git config --add remote.origin.fetch +refs/heads/*:refs/remotes/origin/* # timeout=10
Avoid second fetch
Checking out Revision b652a52252ee27894806ccc46527f89f28087d66 (DEV)
 > git config core.sparsecheckout # timeout=10
 > git checkout -f b652a52252ee27894806ccc46527f89f28087d66 # timeout=10
Commit message: "all files are added"
 > git rev-list --no-walk b652a52252ee27894806ccc46527f89f28087d66 # timeout=10
[Pipeline] }
[Pipeline] // stage
[Pipeline] withEnv
[Pipeline] {
[Pipeline] stage
[Pipeline] { (Build Docker Dev Image)
[Pipeline] script
[Pipeline] {
[Pipeline] isUnix
[Pipeline] withEnv
[Pipeline] {
[Pipeline] sh
+ docker build -t sanu28221/dev_branch:latest .
#0 building with "default" instance using docker driver

#1 [internal] load build definition from Dockerfile
#1 transferring dockerfile: 131B done
#1 DONE 0.1s

#2 [internal] load metadata for docker.io/library/nginx:alpine
#2 DONE 7.8s

#3 [internal] load .dockerignore
#3 transferring context: 2B done
#3 DONE 0.0s

#4 [1/3] FROM docker.io/library/nginx:alpine@sha256:31bad00311cb5eeb8a6648beadcf67277a175da89989f14727420a80e2e76742
#4 DONE 0.0s

#5 [internal] load build context
#5 transferring context: 469B done
#5 DONE 0.0s

#6 [2/3] COPY default.conf /etc/nginx/conf.d/
#6 CACHED

#7 [3/3] COPY index.html /usr/share/nginx/html/
#7 CACHED

#8 exporting to image
#8 exporting layers done
#8 writing image sha256:09a010fb572c8dac6632cce4006caaa4afdc13c8337b68655af07d6954aca3ae done
#8 naming to docker.io/sanu28221/dev_branch:latest done
#8 DONE 0.0s
[Pipeline] }
[Pipeline] // withEnv
[Pipeline] withEnv
[Pipeline] {
[Pipeline] withDockerRegistry
$ docker login -u sanu28221 -p ******** https://registry.hub.docker.com/sanu28221/
WARNING! Using --password via the CLI is insecure. Use --password-stdin.
WARNING! Your password will be stored unencrypted in /var/jenkins_home/workspace/Question1_DEV@tmp/eda83599-39e3-4505-be23-6f96743965ed/config.json.
Configure a credential helper to remove this warning. See
https://docs.docker.com/engine/reference/commandline/login/#credentials-store

Login Succeeded
[Pipeline] {
[Pipeline] isUnix
[Pipeline] withEnv
[Pipeline] {
[Pipeline] sh
+ docker tag sanu28221/dev_branch:latest registry.hub.docker.com/sanu28221/dev_branch:latest
[Pipeline] }
[Pipeline] // withEnv
[Pipeline] isUnix
[Pipeline] withEnv
[Pipeline] {
[Pipeline] sh
+ docker push registry.hub.docker.com/sanu28221/dev_branch:latest
The push refers to repository [registry.hub.docker.com/sanu28221/dev_branch]
8991bdea697b: Preparing
3ebfa5feb5c9: Preparing
13c52683b537: Preparing
337b7d64083b: Preparing
cdd311f34c29: Preparing
3e8ad8bcb0ac: Preparing
74b4ff8dbbd1: Preparing
c018a48a857c: Preparing
0f73163669d4: Preparing
aedc3bda2944: Preparing
c018a48a857c: Waiting
aedc3bda2944: Waiting
0f73163669d4: Waiting
3e8ad8bcb0ac: Waiting
74b4ff8dbbd1: Waiting
8991bdea697b: Pushed
3ebfa5feb5c9: Pushed
337b7d64083b: Pushed
cdd311f34c29: Pushed
74b4ff8dbbd1: Pushed
c018a48a857c: Pushed
3e8ad8bcb0ac: Pushed
13c52683b537: Pushed
aedc3bda2944: Pushed
0f73163669d4: Retrying in 5 seconds
0f73163669d4: Retrying in 4 seconds
0f73163669d4: Retrying in 3 seconds
0f73163669d4: Retrying in 2 seconds
0f73163669d4: Retrying in 1 second
0f73163669d4: Pushed
latest: digest: sha256:7bff05749391484e675ca28e979de4cbfa279ef3f047465d3e166684baf14263 size: 2403
[Pipeline] }
[Pipeline] // withEnv
[Pipeline] }
[Pipeline] // withDockerRegistry
[Pipeline] }
[Pipeline] // withEnv
[Pipeline] }
[Pipeline] // script
[Pipeline] }
[Pipeline] // stage
[Pipeline] stage
[Pipeline] { (Build Docker QA Image)
Stage "Build Docker QA Image" skipped due to when conditional
[Pipeline] }
[Pipeline] // stage
[Pipeline] stage
[Pipeline] { (Declarative: Post Actions)
[Pipeline] echo
Deleting Project now !! 
[Pipeline] deleteDir
[Pipeline] }
[Pipeline] // stage
[Pipeline] }
[Pipeline] // withEnv
[Pipeline] }
[Pipeline] // node
[Pipeline] End of Pipeline
Finished: SUCCESS

QA BRANCH
Started by user saniya ahaikh
 > git rev-parse --resolve-git-dir /var/jenkins_home/caches/git-0ea74179bf36a1e3b933260d312cc235/.git # timeout=10
Setting origin to https://github.com/Saniya2822/Jenkins.git
 > git config remote.origin.url https://github.com/Saniya2822/Jenkins.git # timeout=10
Fetching origin...
Fetching upstream changes from origin
 > git --version # timeout=10
 > git --version # 'git version 2.39.2'
 > git config --get remote.origin.url # timeout=10
using GIT_SSH to set credentials GIT_CREDS
Verifying host key using known hosts file
You're using 'Known hosts file' strategy to verify ssh host keys, but your known_hosts file does not exist, please go to 'Manage Jenkins' -> 'Security' -> 'Git Host Key Verification Configuration' and configure host key verification.
 > git fetch --tags --force --progress -- origin +refs/heads/*:refs/remotes/origin/* # timeout=10
Seen branch in repository origin/DEV
Seen branch in repository origin/QA
Seen branch in repository origin/main
Seen 3 remote branches
Obtained Jenkinsfile from 272177f2196bee2b06080ed8159a7761600c6044
[Pipeline] Start of Pipeline
[Pipeline] node
Running on Jenkins in /var/jenkins_home/workspace/Question1_QA
[Pipeline] {
[Pipeline] stage
[Pipeline] { (Declarative: Checkout SCM)
[Pipeline] checkout
Selected Git installation does not exist. Using Default
The recommended git tool is: NONE
using credential GIT_CREDS
Cloning the remote Git repository
Cloning with configured refspecs honoured and without tags
Cloning repository https://github.com/Saniya2822/Jenkins.git
 > git init /var/jenkins_home/workspace/Question1_QA # timeout=10
Fetching upstream changes from https://github.com/Saniya2822/Jenkins.git
 > git --version # timeout=10
 > git --version # 'git version 2.39.2'
using GIT_SSH to set credentials GIT_CREDS
Verifying host key using known hosts file
You're using 'Known hosts file' strategy to verify ssh host keys, but your known_hosts file does not exist, please go to 'Manage Jenkins' -> 'Security' -> 'Git Host Key Verification Configuration' and configure host key verification.
 > git fetch --no-tags --force --progress -- https://github.com/Saniya2822/Jenkins.git +refs/heads/*:refs/remotes/origin/* # timeout=10
 > git config remote.origin.url https://github.com/Saniya2822/Jenkins.git # timeout=10
 > git config --add remote.origin.fetch +refs/heads/*:refs/remotes/origin/* # timeout=10
Avoid second fetch
Checking out Revision 272177f2196bee2b06080ed8159a7761600c6044 (QA)
 > git config core.sparsecheckout # timeout=10
 > git checkout -f 272177f2196bee2b06080ed8159a7761600c6044 # timeout=10
Commit message: "Merge branch 'DEV' into QA"
 > git rev-list --no-walk 335d66ca8700c4a729d20d277396c87339255097 # timeout=10
[Pipeline] }
[Pipeline] // stage
[Pipeline] withEnv
[Pipeline] {
[Pipeline] stage
[Pipeline] { (Build Docker Dev Image)
Stage "Build Docker Dev Image" skipped due to when conditional
[Pipeline] }
[Pipeline] // stage
[Pipeline] stage
[Pipeline] { (Build Docker QA Image)
[Pipeline] script
[Pipeline] {
[Pipeline] isUnix
[Pipeline] withEnv
[Pipeline] {
[Pipeline] sh
+ docker build -t sanu28221/dev_branch:latest .
#0 building with "default" instance using docker driver

#1 [internal] load build definition from Dockerfile
#1 transferring dockerfile: 131B done
#1 DONE 0.1s

#2 [internal] load metadata for docker.io/library/nginx:alpine
#2 DONE 4.3s

#3 [internal] load .dockerignore
#3 transferring context: 2B done
#3 DONE 0.0s

#4 [1/3] FROM docker.io/library/nginx:alpine@sha256:31bad00311cb5eeb8a6648beadcf67277a175da89989f14727420a80e2e76742
#4 DONE 0.0s

#5 [internal] load build context
#5 transferring context: 469B done
#5 DONE 0.0s

#6 [2/3] COPY default.conf /etc/nginx/conf.d/
#6 CACHED

#7 [3/3] COPY index.html /usr/share/nginx/html/
#7 CACHED

#8 exporting to image
#8 exporting layers done
#8 writing image sha256:09a010fb572c8dac6632cce4006caaa4afdc13c8337b68655af07d6954aca3ae done
#8 naming to docker.io/sanu28221/dev_branch:latest
#8 naming to docker.io/sanu28221/dev_branch:latest 0.0s done
#8 DONE 0.0s
[Pipeline] }
[Pipeline] // withEnv
[Pipeline] withEnv
[Pipeline] {
[Pipeline] withDockerRegistry
$ docker login -u sanu28221 -p ******** https://registry.hub.docker.com/sanu28221/
WARNING! Using --password via the CLI is insecure. Use --password-stdin.
WARNING! Your password will be stored unencrypted in /var/jenkins_home/workspace/Question1_QA@tmp/57e1c78e-d8e5-48bb-bb65-2b9a33705a6b/config.json.
Configure a credential helper to remove this warning. See
https://docs.docker.com/engine/reference/commandline/login/#credentials-store

Login Succeeded
[Pipeline] {
[Pipeline] isUnix
[Pipeline] withEnv
[Pipeline] {
[Pipeline] sh
+ docker tag sanu28221/dev_branch:latest registry.hub.docker.com/sanu28221/dev_branch:latest
[Pipeline] }
[Pipeline] // withEnv
[Pipeline] isUnix
[Pipeline] withEnv
[Pipeline] {
[Pipeline] sh
+ docker push registry.hub.docker.com/sanu28221/dev_branch:latest
The push refers to repository [registry.hub.docker.com/sanu28221/dev_branch]
8991bdea697b: Preparing
3ebfa5feb5c9: Preparing
13c52683b537: Preparing
337b7d64083b: Preparing
cdd311f34c29: Preparing
3e8ad8bcb0ac: Preparing
74b4ff8dbbd1: Preparing
c018a48a857c: Preparing
0f73163669d4: Preparing
aedc3bda2944: Preparing
0f73163669d4: Waiting
74b4ff8dbbd1: Waiting
c018a48a857c: Waiting
3e8ad8bcb0ac: Waiting
aedc3bda2944: Waiting
13c52683b537: Layer already exists
cdd311f34c29: Layer already exists
3ebfa5feb5c9: Layer already exists
337b7d64083b: Layer already exists
8991bdea697b: Layer already exists
0f73163669d4: Layer already exists
3e8ad8bcb0ac: Layer already exists
c018a48a857c: Layer already exists
74b4ff8dbbd1: Layer already exists
aedc3bda2944: Layer already exists
latest: digest: sha256:7bff05749391484e675ca28e979de4cbfa279ef3f047465d3e166684baf14263 size: 2403
[Pipeline] }
[Pipeline] // withEnv
[Pipeline] }
[Pipeline] // withDockerRegistry
[Pipeline] }
[Pipeline] // withEnv
[Pipeline] }
[Pipeline] // script
[Pipeline] }
[Pipeline] // stage
[Pipeline] stage
[Pipeline] { (Declarative: Post Actions)
[Pipeline] echo
Deleting Project now !! 
[Pipeline] deleteDir
[Pipeline] }
[Pipeline] // stage
[Pipeline] }
[Pipeline] // withEnv
[Pipeline] }
[Pipeline] // node
[Pipeline] End of Pipeline
Finished: SUCCESS

##############################################################################################################################################

2. Design a Jenkins file to execute any Terraform code, prompting the user for two inputs: Terraform apply and Terraform destroy. 
Depending on the provided inputs, execute the corresponding Terraform command accordingly.

SOLUTION:-

Started by user saniya ahaikh
 > git rev-parse --resolve-git-dir /var/jenkins_home/caches/git-a079f63481f0b348518cdd0bb37f496f/.git # timeout=10
Setting origin to https://github.com/Saniya2822/JENKINS-.git
 > git config remote.origin.url https://github.com/Saniya2822/JENKINS-.git # timeout=10
Fetching origin...
Fetching upstream changes from origin
 > git --version # timeout=10
 > git --version # 'git version 2.39.2'
 > git config --get remote.origin.url # timeout=10
using GIT_SSH to set credentials GIT_CREDS
Verifying host key using known hosts file
You're using 'Known hosts file' strategy to verify ssh host keys, but your known_hosts file does not exist, please go to 'Manage Jenkins' -> 'Security' -> 'Git Host Key Verification Configuration' and configure host key verification.
 > git fetch --tags --force --progress -- origin +refs/heads/*:refs/remotes/origin/* # timeout=10
Seen branch in repository origin/main
Seen branch in repository origin/master
Seen 2 remote branches
Obtained Jenkinsfile from 4ad9c451caba88e482cf940c2cc27c84e1da3073
[Pipeline] Start of Pipeline
[Pipeline] node
Running on Jenkins in /var/jenkins_home/workspace/Question2_master
[Pipeline] {
[Pipeline] stage
[Pipeline] { (Declarative: Checkout SCM)
[Pipeline] checkout
Selected Git installation does not exist. Using Default
The recommended git tool is: NONE
using credential GIT_CREDS
Cloning the remote Git repository
Cloning with configured refspecs honoured and without tags
Cloning repository https://github.com/Saniya2822/JENKINS-.git
 > git init /var/jenkins_home/workspace/Question2_master # timeout=10
Fetching upstream changes from https://github.com/Saniya2822/JENKINS-.git
 > git --version # timeout=10
 > git --version # 'git version 2.39.2'
using GIT_SSH to set credentials GIT_CREDS
Verifying host key using known hosts file
You're using 'Known hosts file' strategy to verify ssh host keys, but your known_hosts file does not exist, please go to 'Manage Jenkins' -> 'Security' -> 'Git Host Key Verification Configuration' and configure host key verification.
 > git fetch --no-tags --force --progress -- https://github.com/Saniya2822/JENKINS-.git +refs/heads/*:refs/remotes/origin/* # timeout=10
 > git config remote.origin.url https://github.com/Saniya2822/JENKINS-.git # timeout=10
 > git config --add remote.origin.fetch +refs/heads/*:refs/remotes/origin/* # timeout=10
Avoid second fetch
Checking out Revision 4ad9c451caba88e482cf940c2cc27c84e1da3073 (master)
 > git config core.sparsecheckout # timeout=10
 > git checkout -f 4ad9c451caba88e482cf940c2cc27c84e1da3073 # timeout=10
Commit message: "all files are added"
 > git rev-list --no-walk 4ad9c451caba88e482cf940c2cc27c84e1da3073 # timeout=10
[Pipeline] }
[Pipeline] // stage
[Pipeline] withEnv
[Pipeline] {
[Pipeline] withEnv
[Pipeline] {
[Pipeline] stage
[Pipeline] { (Environment Variables)
[Pipeline] script
[Pipeline] {
[Pipeline] withCredentials
Masking supported pattern matches of $AWS_ACCESS_KEY_ID or $AWS_SECRET_ACCESS_KEY
[Pipeline] {
[Pipeline] }
[Pipeline] // withCredentials
[Pipeline] }
[Pipeline] // script
[Pipeline] }
[Pipeline] // stage
[Pipeline] stage
[Pipeline] { (Terraform Execution)
[Pipeline] script
[Pipeline] {
[Pipeline] echo
Initializing Terraform...
[Pipeline] sh
+ terraform init

[0m[1mInitializing the backend...[0m

[0m[1mInitializing provider plugins...[0m
- Finding hashicorp/aws versions matching "5.40.0"...
- Installing hashicorp/aws v5.40.0...
- Installed hashicorp/aws v5.40.0 (signed by HashiCorp)

Terraform has created a lock file [1m.terraform.lock.hcl[0m to record the provider
selections it made above. Include this file in your version control repository
so that Terraform can guarantee to make the same selections by default when
you run "terraform init" in the future.[0m

[0m[1m[32mTerraform has been successfully initialized![0m[32m[0m
[0m[32m
You may now begin working with Terraform. Try running "terraform plan" to see
any changes that are required for your infrastructure. All Terraform commands
should now work.

If you ever set or change modules or backend configuration for Terraform,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.[0m
[Pipeline] }
[Pipeline] // script
[Pipeline] }
[Pipeline] // stage
[Pipeline] stage
[Pipeline] { (Prompt for Terraform Action)
[Pipeline] script
[Pipeline] {
[Pipeline] input
Input requested
Approved by saniya ahaikh
[Pipeline] sh
+ terraform apply -auto-approve

Terraform used the selected providers to generate the following execution
plan. Resource actions are indicated with the following symbols:
  [32m+[0m create[0m

Terraform will perform the following actions:

[1m  # aws_instance.this[0m will be created
[0m  [32m+[0m[0m resource "aws_instance" "this" {
      [32m+[0m[0m ami                                  = "ami-05295b6e6c790593e"
      [32m+[0m[0m arn                                  = (known after apply)
      [32m+[0m[0m associate_public_ip_address          = (known after apply)
      [32m+[0m[0m availability_zone                    = (known after apply)
      [32m+[0m[0m cpu_core_count                       = (known after apply)
      [32m+[0m[0m cpu_threads_per_core                 = (known after apply)
      [32m+[0m[0m disable_api_stop                     = (known after apply)
      [32m+[0m[0m disable_api_termination              = (known after apply)
      [32m+[0m[0m ebs_optimized                        = (known after apply)
      [32m+[0m[0m get_password_data                    = false
      [32m+[0m[0m host_id                              = (known after apply)
      [32m+[0m[0m host_resource_group_arn              = (known after apply)
      [32m+[0m[0m iam_instance_profile                 = (known after apply)
      [32m+[0m[0m id                                   = (known after apply)
      [32m+[0m[0m instance_initiated_shutdown_behavior = (known after apply)
      [32m+[0m[0m instance_lifecycle                   = (known after apply)
      [32m+[0m[0m instance_state                       = (known after apply)
      [32m+[0m[0m instance_type                        = "t2.micro"
      [32m+[0m[0m ipv6_address_count                   = (known after apply)
      [32m+[0m[0m ipv6_addresses                       = (known after apply)
      [32m+[0m[0m key_name                             = "deployer-key"
      [32m+[0m[0m monitoring                           = (known after apply)
      [32m+[0m[0m outpost_arn                          = (known after apply)
      [32m+[0m[0m password_data                        = (known after apply)
      [32m+[0m[0m placement_group                      = (known after apply)
      [32m+[0m[0m placement_partition_number           = (known after apply)
      [32m+[0m[0m primary_network_interface_id         = (known after apply)
      [32m+[0m[0m private_dns                          = (known after apply)
      [32m+[0m[0m private_ip                           = (known after apply)
      [32m+[0m[0m public_dns                           = (known after apply)
      [32m+[0m[0m public_ip                            = (known after apply)
      [32m+[0m[0m secondary_private_ips                = (known after apply)
      [32m+[0m[0m security_groups                      = (known after apply)
      [32m+[0m[0m source_dest_check                    = true
      [32m+[0m[0m spot_instance_request_id             = (known after apply)
      [32m+[0m[0m subnet_id                            = (known after apply)
      [32m+[0m[0m tags_all                             = (known after apply)
      [32m+[0m[0m tenancy                              = (known after apply)
      [32m+[0m[0m user_data                            = (known after apply)
      [32m+[0m[0m user_data_base64                     = (known after apply)
      [32m+[0m[0m user_data_replace_on_change          = false
      [32m+[0m[0m vpc_security_group_ids               = (known after apply)
    }

[1m  # aws_key_pair.deployer[0m will be created
[0m  [32m+[0m[0m resource "aws_key_pair" "deployer" {
      [32m+[0m[0m arn             = (known after apply)
      [32m+[0m[0m fingerprint     = (known after apply)
      [32m+[0m[0m id              = (known after apply)
      [32m+[0m[0m key_name        = "deployer-key"
      [32m+[0m[0m key_name_prefix = (known after apply)
      [32m+[0m[0m key_pair_id     = (known after apply)
      [32m+[0m[0m key_type        = (known after apply)
      [32m+[0m[0m public_key      = "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDQzL4Q9Ih4/fljc2ATSeJjjB1w+W69RTtXRqcvd4m/ZoEwk0j40QKCUCjx3CDH81xr2BbHVH/l3DwlRCSLK1lBAFaTWmcYXwsnZsjcZ4/WovEsP+Tdnu8LSN5VHgzvoeutGz0p8+vDWkzS1zCVDAn+mMTu9zAntWZwTKIzRvneldz2u6BjtKNS989CoVn82RvhemXzG6h/a+G3ykDHLbqlaCufu5NgfIow1YoZJF/njHuMfXw6zxRjTgGwkU1y5nVmzRz7XxoTHdoL6iKbOb0rLHJNoYCQzckxi5ROxS/y9Fi+FlThp4Se49AJWw1jjkId8FSzywrw0G9kF/Js3a5Ofr3XXY98HsCc+F+d2iF6PfR/IfweufVOYs35SVYARcz3Kp4egQSDDA+EQWlK6JlEPCag9KnKXvP8mS/I5jS0jYMV7cNf1SeZWEGJaLiXIbOiP+6jLon3dAh27LZuECbdge9L6BmnICiltOgrBxuWkcZiC4SqlDLWmRcrUItEUUs="
      [32m+[0m[0m tags_all        = (known after apply)
    }

[1mPlan:[0m 2 to add, 0 to change, 0 to destroy.
[0m[0m[1maws_key_pair.deployer: Creating...[0m[0m
[0m[1maws_key_pair.deployer: Creation complete after 0s [id=deployer-key][0m
[0m[1maws_instance.this: Creating...[0m[0m
[0m[1maws_instance.this: Still creating... [10s elapsed][0m[0m
[0m[1maws_instance.this: Still creating... [20s elapsed][0m[0m
[0m[1maws_instance.this: Creation complete after 22s [id=i-0defa977bb1ad5d20][0m
[0m[1m[32m
Apply complete! Resources: 2 added, 0 changed, 0 destroyed.
[0m
[Pipeline] }
[Pipeline] // script
[Pipeline] }
[Pipeline] // stage
[Pipeline] stage
[Pipeline] { (Declarative: Post Actions)
[Pipeline] echo
Cleaning up...
[Pipeline] deleteDir
[Pipeline] }
[Pipeline] // stage
[Pipeline] }
[Pipeline] // withEnv
[Pipeline] }
[Pipeline] // withEnv
[Pipeline] }
[Pipeline] // node
[Pipeline] End of Pipeline
Finished: SUCCESS